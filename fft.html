<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Live FFT — Physics of Sound</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      background: #0f1117;
      color: #e0e0e0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 24px 16px;
    }

    h1 {
      font-size: 1.6rem;
      font-weight: 600;
      margin-bottom: 4px;
      color: #f0f0f0;
    }
    .subtitle {
      font-size: 0.85rem;
      color: #888;
      margin-bottom: 18px;
    }

    /* ── Controls bar ── */
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: center;
      justify-content: center;
      background: #1a1d27;
      border: 1px solid #2a2d3a;
      border-radius: 10px;
      padding: 12px 20px;
      margin-bottom: 16px;
      max-width: 960px;
      width: 100%;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .control-group label {
      font-size: 0.8rem;
      color: #aaa;
      white-space: nowrap;
    }

    /* Buttons */
    .btn {
      border: none;
      border-radius: 6px;
      padding: 7px 16px;
      font-size: 0.82rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s, transform 0.1s;
    }
    .btn:active { transform: scale(0.96); }

    .btn-start {
      background: #3b82f6;
      color: #fff;
    }
    .btn-start:hover { background: #2563eb; }

    .btn-pause {
      background: #f59e0b;
      color: #1a1a1a;
    }
    .btn-pause:hover { background: #d97706; }

    /* Toggle switch */
    .toggle-wrapper {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .toggle {
      position: relative;
      width: 38px;
      height: 20px;
      background: #374151;
      border-radius: 10px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .toggle.active { background: #3b82f6; }
    .toggle::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 16px;
      height: 16px;
      background: #fff;
      border-radius: 50%;
      transition: transform 0.2s;
    }
    .toggle.active::after { transform: translateX(18px); }

    /* Radio pills */
    .pill-group {
      display: flex;
      gap: 0;
      border-radius: 6px;
      overflow: hidden;
      border: 1px solid #2a2d3a;
    }
    .pill-group input[type="radio"] { display: none; }
    .pill-group label {
      padding: 5px 10px;
      font-size: 0.75rem;
      color: #aaa;
      background: #1a1d27;
      cursor: pointer;
      transition: background 0.15s, color 0.15s;
      border-right: 1px solid #2a2d3a;
      white-space: nowrap;
    }
    .pill-group label:last-of-type { border-right: none; }
    .pill-group input[type="radio"]:checked + label {
      background: #3b82f6;
      color: #fff;
    }

    /* ── Chart canvas area ── */
    .canvas-wrapper {
      position: relative;
      max-width: 960px;
      width: 100%;
      background: #000;
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid #2a2d3a;
      cursor: crosshair;
    }
    canvas {
      display: block;
      width: 100%;
    }

    /* Frequency marker lines (vertical) */
    .marker-line {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 0;
      border-left: 2px dashed rgba(255, 255, 255, 0.85);
      pointer-events: none;
      z-index: 10;
    }
    .marker-label {
      position: absolute;
      top: 8px;
      left: 8px;
      background: rgba(0, 0, 0, 0.75);
      color: #fff;
      font-size: 0.72rem;
      font-weight: 600;
      padding: 2px 8px;
      border-radius: 4px;
      white-space: nowrap;
      pointer-events: auto;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .marker-delete {
      cursor: pointer;
      color: #f87171;
      font-size: 0.85rem;
      font-weight: 700;
      line-height: 1;
      padding: 0 2px;
    }
    .marker-delete:hover { color: #ef4444; }

    /* Drag handle at bottom of marker line */
    .marker-drag-handle {
      position: absolute;
      bottom: 8px;
      left: -11px;
      width: 24px;
      height: 22px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: ew-resize;
      pointer-events: auto;
      color: rgba(255,255,255,0.8);
      font-size: 0.65rem;
      line-height: 1;
      letter-spacing: -2px;
      user-select: none;
      background: rgba(0,0,0,0.55);
      border-radius: 3px;
    }
    .marker-drag-handle:hover {
      color: #fff;
      background: rgba(59,130,246,0.6);
    }

    /* Instruction hint */
    .hint {
      font-size: 0.75rem;
      color: #666;
      margin-top: 10px;
      text-align: center;
    }
  </style>
</head>
<body>

  <h1>Live FFT</h1>
  <p class="subtitle">Physics of Sound &mdash; Real-time frequency spectrum from your microphone</p>

  <!-- Controls -->
  <div class="controls">
    <button id="btnStart" class="btn btn-start">Start Microphone</button>
    <button id="btnPause" class="btn btn-pause" disabled>Pause</button>

    <div class="toggle-wrapper">
      <label style="font-size:0.8rem;color:#aaa;">Log scale</label>
      <div id="toggleLog" class="toggle" role="button" tabindex="0" aria-label="Toggle log scale"></div>
    </div>

    <div class="control-group">
      <label>Sensitivity:</label>
      <input type="range" id="sensitivity" min="0" max="100" value="50"
             style="width:90px; accent-color:#3b82f6; cursor:pointer;">
    </div>

    <div class="control-group">
      <label>Range:</label>
      <div class="pill-group">
        <input type="radio" name="frange" id="fr1000" value="1000">
        <label for="fr1000">1 kHz</label>
        <input type="radio" name="frange" id="fr2000" value="2000">
        <label for="fr2000">2 kHz</label>
        <input type="radio" name="frange" id="fr4000" value="4000" checked>
        <label for="fr4000">4 kHz</label>
        <input type="radio" name="frange" id="fr20000" value="20000">
        <label for="fr20000">20 kHz</label>
      </div>
    </div>

    <div class="control-group">
      <label>Precision:</label>
      <div class="pill-group">
        <input type="radio" name="precision" id="precLow" value="low">
        <label for="precLow">Low</label>
        <input type="radio" name="precision" id="precMed" value="medium" checked>
        <label for="precMed">Medium</label>
        <input type="radio" name="precision" id="precHigh" value="high">
        <label for="precHigh">High</label>
      </div>
    </div>
  </div>

  <!-- Canvas -->
  <div class="canvas-wrapper" id="canvasWrapper">
    <canvas id="fftCanvas"></canvas>
    <!-- Markers inserted here dynamically -->
  </div>

  <p class="hint">Click on the chart to place a frequency marker line. Use the arrow handle at the bottom to drag and reposition.</p>

<script>
(function () {
  'use strict';

  // ── DOM refs ──
  const canvas      = document.getElementById('fftCanvas');
  const ctx         = canvas.getContext('2d');
  const wrapper     = document.getElementById('canvasWrapper');
  const btnStart    = document.getElementById('btnStart');
  const btnPause    = document.getElementById('btnPause');
  const toggleLog   = document.getElementById('toggleLog');
  const sensitivitySlider = document.getElementById('sensitivity');

  // ── Constants ──
  const WIDTH  = 960;
  const HEIGHT = 400;
  const PAD_LEFT   = 52;
  const PAD_RIGHT  = 16;
  const PAD_TOP    = 16;
  const PAD_BOTTOM = 36;
  const PLOT_W = WIDTH - PAD_LEFT - PAD_RIGHT;
  const PLOT_H = HEIGHT - PAD_TOP - PAD_BOTTOM;

  canvas.width  = WIDTH;
  canvas.height = HEIGHT;

  // ── State ──
  const FFT_SIZES = { low: 2048, medium: 4096, high: 8192 };
  let fftSize   = FFT_SIZES.medium;
  let audioCtx, analyser, micStream, dataArray;
  let running   = false;
  let paused    = false;
  let logScale  = false;
  let maxFreq   = 4000;
  let animId    = null;
  let frozenData = null;   // snapshot when paused

  // Marker lines: { id, freq, el }
  let markers = [];
  let nextMarkerId = 0;

  // ── Gradient for the fill ──
  const fillGrad = ctx.createLinearGradient(0, PAD_TOP, 0, PAD_TOP + PLOT_H);
  fillGrad.addColorStop(0, 'rgba(59,130,246,0.45)');
  fillGrad.addColorStop(1, 'rgba(59,130,246,0.02)');

  // ── Frequency ↔ X mapping ──
  function freqToX(freq) {
    if (logScale) {
      const minF = 20;
      const logMin = Math.log10(minF);
      const logMax = Math.log10(maxFreq);
      const logF   = Math.log10(Math.max(minF, freq));
      const ratio  = (logF - logMin) / (logMax - logMin);
      return PAD_LEFT + ratio * PLOT_W;
    }
    return PAD_LEFT + (freq / maxFreq) * PLOT_W;
  }

  function xToFreq(x) {
    const px = x - PAD_LEFT;
    if (logScale) {
      const minF = 20;
      const logMin = Math.log10(minF);
      const logMax = Math.log10(maxFreq);
      const ratio  = px / PLOT_W;
      return Math.pow(10, logMin + ratio * (logMax - logMin));
    }
    return (px / PLOT_W) * maxFreq;
  }

  // ── Amplitude → Y ──
  function ampToY(val) {
    // val 0..255
    const norm = val / 255;
    return PAD_TOP + PLOT_H - norm * PLOT_H;
  }

  // ── Nice tick step ──
  function niceStep(range, targetTicks) {
    const rough = range / targetTicks;
    const mag = Math.pow(10, Math.floor(Math.log10(rough)));
    const res = rough / mag;
    if (res <= 1.5) return mag;
    if (res <= 3.5) return 2 * mag;
    if (res <= 7.5) return 5 * mag;
    return 10 * mag;
  }

  // ── Draw the FFT frame ──
  function drawFrame(data) {
    if (!data) return;

    const nyquist    = audioCtx.sampleRate / 2;
    const binCount   = analyser.frequencyBinCount;
    const freqPerBin = nyquist / binCount;

    ctx.clearRect(0, 0, WIDTH, HEIGHT);

    // Background
    ctx.fillStyle = '#0a0c12';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);

    // Plot area background
    ctx.fillStyle = '#0f1219';
    ctx.fillRect(PAD_LEFT, PAD_TOP, PLOT_W, PLOT_H);

    // ── Grid lines ──
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.lineWidth = 1;

    // Horizontal grid (amplitude)
    for (let a = 0.25; a <= 1.0; a += 0.25) {
      const y = ampToY(a * 255);
      ctx.beginPath();
      ctx.moveTo(PAD_LEFT, y);
      ctx.lineTo(PAD_LEFT + PLOT_W, y);
      ctx.stroke();
    }

    // Frequency ticks
    let freqTicks;
    if (logScale) {
      freqTicks = [20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000].filter(f => f <= maxFreq && f >= 20);
    } else {
      const step = niceStep(maxFreq, 8);
      freqTicks = [];
      for (let f = step; f <= maxFreq; f += step) freqTicks.push(f);
    }

    // Vertical grid
    for (const f of freqTicks) {
      const x = freqToX(f);
      if (x < PAD_LEFT || x > PAD_LEFT + PLOT_W) continue;
      ctx.beginPath();
      ctx.moveTo(x, PAD_TOP);
      ctx.lineTo(x, PAD_TOP + PLOT_H);
      ctx.stroke();
    }

    // ── Build path from frequency data ──
    ctx.beginPath();
    let started = false;

    for (let px = 0; px <= PLOT_W; px++) {
      const freq = xToFreq(PAD_LEFT + px);
      if (freq < 0 || freq > nyquist) continue;

      const bin   = freq / freqPerBin;
      const binLo = Math.floor(bin);
      const binHi = Math.min(binLo + 1, binCount - 1);
      const frac  = bin - binLo;
      const val   = data[binLo] * (1 - frac) + data[binHi] * frac;
      const y     = ampToY(val);

      if (!started) {
        ctx.moveTo(PAD_LEFT + px, y);
        started = true;
      } else {
        ctx.lineTo(PAD_LEFT + px, y);
      }
    }

    // Stroke the line
    ctx.strokeStyle = '#3b82f6';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Fill under the curve
    ctx.lineTo(PAD_LEFT + PLOT_W, PAD_TOP + PLOT_H);
    ctx.lineTo(PAD_LEFT, PAD_TOP + PLOT_H);
    ctx.closePath();
    ctx.fillStyle = fillGrad;
    ctx.fill();

    // ── Axis labels ──
    ctx.fillStyle = 'rgba(255,255,255,0.45)';
    ctx.font = '10px system-ui, sans-serif';
    ctx.textAlign = 'center';

    // Frequency labels along bottom
    for (const f of freqTicks) {
      const x = freqToX(f);
      if (x < PAD_LEFT + 5 || x > PAD_LEFT + PLOT_W - 5) continue;
      const label = f >= 1000 ? (f / 1000) + 'k' : f + '';
      ctx.fillText(label, x, PAD_TOP + PLOT_H + 18);
    }

    // "Hz" label
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.fillText('Hz', PAD_LEFT + PLOT_W + 2, PAD_TOP + PLOT_H + 18);

    // Amplitude labels along left
    ctx.textAlign = 'right';
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    for (let a = 0; a <= 1.0; a += 0.25) {
      const y = ampToY(a * 255);
      ctx.fillText(Math.round(a * 100) + '%', PAD_LEFT - 6, y + 3);
    }

    // ── Plot border ──
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.lineWidth = 1;
    ctx.strokeRect(PAD_LEFT, PAD_TOP, PLOT_W, PLOT_H);
  }

  // ── Animation loop ──
  function animLoop() {
    if (!running || paused) return;
    analyser.getByteFrequencyData(dataArray);
    drawFrame(dataArray);
    animId = requestAnimationFrame(animLoop);
  }

  // ── Start / Pause ──
  async function startMic() {
    if (running) {
      paused = false;
      btnPause.textContent = 'Pause';
      frozenData = null;
      animLoop();
      return;
    }

    try {
      micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    } catch (err) {
      alert('Microphone access denied. Please allow microphone access and try again.');
      return;
    }

    audioCtx  = new (window.AudioContext || window.webkitAudioContext)();
    analyser  = audioCtx.createAnalyser();
    analyser.fftSize = fftSize;
    analyser.smoothingTimeConstant = 0.75;
    const sensVal = parseInt(sensitivitySlider.value, 10);
    analyser.minDecibels = -50 - sensVal * 0.7;
    analyser.maxDecibels = -10 - sensVal * 0.1;

    const source = audioCtx.createMediaStreamSource(micStream);
    source.connect(analyser);
    dataArray = new Uint8Array(analyser.frequencyBinCount);

    running = true;
    paused  = false;
    btnStart.textContent = 'Restart';
    btnPause.disabled = false;
    animLoop();
  }

  function togglePause() {
    if (!running) return;
    paused = !paused;
    btnPause.textContent = paused ? 'Resume' : 'Pause';
    if (paused) {
      // Freeze current data for display
      frozenData = new Uint8Array(dataArray);
    } else {
      frozenData = null;
      animLoop();
    }
  }

  btnStart.addEventListener('click', startMic);
  btnPause.addEventListener('click', togglePause);

  // ── Log scale toggle ──
  toggleLog.addEventListener('click', () => {
    logScale = !logScale;
    toggleLog.classList.toggle('active', logScale);
    repositionMarkers();
    if (paused && frozenData) drawFrame(frozenData);
  });
  toggleLog.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggleLog.click(); }
  });

  // ── Sensitivity slider ──
  sensitivitySlider.addEventListener('input', () => {
    if (!analyser) return;
    const val = parseInt(sensitivitySlider.value, 10);
    analyser.minDecibels = -50 - val * 0.7;
    analyser.maxDecibels = -10 - val * 0.1;
  });

  // ── Frequency range radio ──
  document.querySelectorAll('input[name="frange"]').forEach(radio => {
    radio.addEventListener('change', () => {
      maxFreq = parseInt(radio.value, 10);
      removeAllMarkers();
      repositionMarkers();
      if (paused && frozenData) drawFrame(frozenData);
    });
  });

  // ── Precision radio ──
  document.querySelectorAll('input[name="precision"]').forEach(radio => {
    radio.addEventListener('change', () => {
      fftSize = FFT_SIZES[radio.value];
      if (analyser) {
        analyser.fftSize = fftSize;
        dataArray = new Uint8Array(analyser.frequencyBinCount);
      }
    });
  });

  // ── Marker lines (vertical) ──
  function addMarker(freq) {
    const id = nextMarkerId++;
    const x  = freqToX(freq);

    const lineEl = document.createElement('div');
    lineEl.className = 'marker-line';
    lineEl.style.left = x + 'px';

    // Drag handle at bottom with left/right arrows
    const handleEl = document.createElement('div');
    handleEl.className = 'marker-drag-handle';
    handleEl.innerHTML = '&#9664;&#9654;';
    handleEl.title = 'Drag to reposition';
    lineEl.appendChild(handleEl);

    const labelEl = document.createElement('div');
    labelEl.className = 'marker-label';
    labelEl.innerHTML = `<span class="marker-freq-text">${formatFreq(freq)}</span><span class="marker-delete" title="Remove marker">&times;</span>`;
    lineEl.appendChild(labelEl);

    wrapper.appendChild(lineEl);

    const marker = { id, freq, el: lineEl, labelEl, handleEl };
    markers.push(marker);

    // Delete handler
    labelEl.querySelector('.marker-delete').addEventListener('click', (e) => {
      e.stopPropagation();
      removeMarker(id);
    });

    // Drag handler
    makeDraggable(marker);
    return marker;
  }

  function removeMarker(id) {
    const idx = markers.findIndex(m => m.id === id);
    if (idx === -1) return;
    markers[idx].el.remove();
    markers.splice(idx, 1);
  }

  function removeAllMarkers() {
    for (const m of markers) m.el.remove();
    markers = [];
  }

  function repositionMarkers() {
    for (const m of markers) {
      const x = freqToX(m.freq);
      m.el.style.left = x + 'px';
      m.el.querySelector('.marker-freq-text').textContent = formatFreq(m.freq);
    }
  }

  function formatFreq(f) {
    if (f >= 1000) return (f / 1000).toFixed(2) + ' kHz';
    return Math.round(f) + ' Hz';
  }

  function makeDraggable(marker) {
    const labelEl = marker.labelEl;
    const handleEl = marker.handleEl;
    let dragging = false;

    labelEl.addEventListener('mousedown', onStart);
    labelEl.addEventListener('touchstart', onStart, { passive: false });
    handleEl.addEventListener('mousedown', onStart);
    handleEl.addEventListener('touchstart', onStart, { passive: false });

    function onStart(e) {
      if (e.target.classList.contains('marker-delete')) return;
      e.preventDefault();
      e.stopPropagation();
      dragging = true;
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onEnd);
      document.addEventListener('touchmove', onMove, { passive: false });
      document.addEventListener('touchend', onEnd);
    }

    function onMove(e) {
      if (!dragging) return;
      e.preventDefault();
      const rect = wrapper.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const scaleX = WIDTH / rect.width;
      let x = (clientX - rect.left) * scaleX;
      x = Math.max(PAD_LEFT, Math.min(PAD_LEFT + PLOT_W, x));

      marker.freq = xToFreq(x);
      marker.el.style.left = x + 'px';
      marker.el.querySelector('.marker-freq-text').textContent = formatFreq(marker.freq);
    }

    function onEnd() {
      dragging = false;
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onEnd);
      document.removeEventListener('touchmove', onMove);
      document.removeEventListener('touchend', onEnd);
    }
  }

  // Click on canvas wrapper to add marker
  wrapper.addEventListener('click', (e) => {
    if (e.target.closest('.marker-label') || e.target.closest('.marker-drag-handle')) return;
    const rect = wrapper.getBoundingClientRect();
    const scaleX = WIDTH / rect.width;
    const x    = (e.clientX - rect.left) * scaleX;
    if (x < PAD_LEFT || x > PAD_LEFT + PLOT_W) return;
    const freq = xToFreq(x);
    if (freq > 0 && freq <= maxFreq) {
      addMarker(freq);
    }
  });

  // ── Draw empty chart on load ──
  function drawEmpty() {
    ctx.fillStyle = '#0a0c12';
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    ctx.fillStyle = '#0f1219';
    ctx.fillRect(PAD_LEFT, PAD_TOP, PLOT_W, PLOT_H);
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.lineWidth = 1;
    ctx.strokeRect(PAD_LEFT, PAD_TOP, PLOT_W, PLOT_H);

    // Frequency axis
    ctx.fillStyle = 'rgba(255,255,255,0.45)';
    ctx.font = '10px system-ui, sans-serif';
    ctx.textAlign = 'center';
    let freqTicks;
    if (logScale) {
      freqTicks = [20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000].filter(f => f <= maxFreq && f >= 20);
    } else {
      const step = niceStep(maxFreq, 8);
      freqTicks = [];
      for (let f = step; f <= maxFreq; f += step) freqTicks.push(f);
    }
    for (const f of freqTicks) {
      const x = freqToX(f);
      if (x < PAD_LEFT + 5 || x > PAD_LEFT + PLOT_W - 5) continue;
      const label = f >= 1000 ? (f / 1000) + 'k' : f + '';
      ctx.fillText(label, x, PAD_TOP + PLOT_H + 18);

      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      ctx.beginPath();
      ctx.moveTo(x, PAD_TOP);
      ctx.lineTo(x, PAD_TOP + PLOT_H);
      ctx.stroke();
    }

    // Amplitude labels
    ctx.textAlign = 'right';
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    for (let a = 0; a <= 1.0; a += 0.25) {
      const y = ampToY(a * 255);
      ctx.fillText(Math.round(a * 100) + '%', PAD_LEFT - 6, y + 3);
    }
  }

  drawEmpty();
})();
</script>

</body>
</html>
