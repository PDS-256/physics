<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Standing Waves in a Tube</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
      background: #f9f9f9;
    }
    h1 {
      margin-bottom: 0.5em;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      align-items: center;
      margin-bottom: 1em;
    }
    .radio-group, .slider-group, .wave-type-group, .button-group {
      background: #fff;
      padding: 1em;
      border: 1px solid #ccc;
      border-radius: 6px;
    }
    .radio-group label,
    .wave-type-group label,
    .slider-group label {
      margin-right: 10px;
    }
    .slider-group input[type="range"] {
      width: 200px;
      margin: 0 10px;
    }
    canvas {
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 6px;
      display: block;
      margin-top: 20px;
    }
  </style>
</head>
<body>

<h1>Standing Waves in a Tube</h1>

<div class="controls">
  <!-- Tube Type: Both Ends Open vs. One End Closed -->
  <div class="radio-group">
    <label>
      <input type="radio" name="tubeType" value="open" checked />
      Both Ends Open
    </label>
    <label>
      <input type="radio" name="tubeType" value="closed" />
      One End Closed
    </label>
  </div>

  <!-- Wave Type: Pressure vs. Displacement -->
  <div class="wave-type-group">
    <label>
      <input type="radio" name="waveType" value="pressure" checked />
      Pressure
    </label>
    <label>
      <input type="radio" name="waveType" value="displacement" />
      Displacement
    </label>
  </div>

  <!-- Slider for Harmonic Number -->
  <div class="slider-group">
    <label for="harmonicSlider">Harmonic (n):</label>
    <input type="range" id="harmonicSlider" min="0" max="5" step="1" value="0"/>
    <span id="harmonicValue">1</span>
  </div>

  <!-- Play/Pause Animation Button -->
  <div class="button-group">
    <button id="toggleAnimBtn">Play</button>
  </div>
</div>

<canvas id="waveCanvas" width="900" height="300"></canvas>

<script>
  /****************************************************
   * 1. GLOBAL PARAMETERS & DOM REFERENCES
   ****************************************************/

  // Tube length in abstract units
  const L = 1.0;

  // Horizontal & vertical margins inside the canvas
  const marginLeft = 70;
  const marginRight = 70;
  const marginTop = 30;
  const marginBottom = 30;

  // For drawing multiple "phase" lines (the black envelope & internal lines)
  const NUM_PHASE_LINES = 0;  // If you want interior "phase snapshots," set > 0
  // We'll rely mainly on the black envelope + the animated wave in blue.

  // Canvas & Context
  const canvas = document.getElementById('waveCanvas');
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;

  // Computed drawing region for the wave
  const tubeWidth = width - marginLeft - marginRight;
  const tubeHeight = height - marginTop - marginBottom;
  const midY = marginTop + tubeHeight / 2;

  // UI Elements
  const tubeTypeRadios = document.getElementsByName('tubeType');
  const waveTypeRadios = document.getElementsByName('waveType');
  const harmonicSlider = document.getElementById('harmonicSlider');
  const harmonicValue = document.getElementById('harmonicValue');
  const toggleAnimBtn = document.getElementById('toggleAnimBtn');

  // Two sets of harmonics:
  //   Open tube: [1, 2, 3, 4, 5, 6, ...]
  //   Closed tube: [1, 3, 5, 7, 9, 11, ...]
  const openTubeHarmonics = [1, 2, 3, 4, 5, 6];
  const closedTubeHarmonics = [1, 3, 5, 7, 9, 11];

  // Track current state
  let tubeType = 'open';         // 'open' or 'closed'
  let waveType = 'pressure';     // 'pressure' or 'displacement'
  let harmonicIndex = 0;         // index in the array
  let isAnimating = false;       // animation state
  let time = 0;                  // time variable for animation
  const dt = 0.04;               // time step per frame
  const omega = 2 * Math.PI * 1; // angular frequency for animation

  /****************************************************
   * 2. EVENT LISTENERS & UI UPDATES
   ****************************************************/

  // 2a. Tube type change
  tubeTypeRadios.forEach(radio => {
    radio.addEventListener('change', (event) => {
      tubeType = event.target.value;
      // Reset to first harmonic in that tube type
      harmonicIndex = 0;
      harmonicSlider.value = 0;
      updateHarmonicDisplay();
      updateSliderRange();
      // Stop animation if it's running
      stopAnimation();
      drawAll();
    });
  });

  // 2b. Wave type change
  waveTypeRadios.forEach(radio => {
    radio.addEventListener('change', (event) => {
      waveType = event.target.value;
      // Stop animation if it's running
      stopAnimation();
      drawAll();
    });
  });

  // 2c. Harmonic slider change
  harmonicSlider.addEventListener('input', () => {
    harmonicIndex = parseInt(harmonicSlider.value, 10);
    updateHarmonicDisplay();
    // Stop animation if it's running
    stopAnimation();
    drawAll();
  });

  // 2d. Play/Pause button
  toggleAnimBtn.addEventListener('click', () => {
    if (isAnimating) {
      stopAnimation();
    } else {
      startAnimation();
    }
  });

  // 2e. Update slider range based on tube type
  function updateSliderRange() {
    if (tubeType === 'open') {
      harmonicSlider.max = openTubeHarmonics.length - 1;
    } else {
      harmonicSlider.max = closedTubeHarmonics.length - 1;
    }
  }

  // 2f. Display the actual harmonic number
  function updateHarmonicDisplay() {
    const n = getCurrentHarmonicNumber();
    harmonicValue.textContent = n.toString();
  }

  // Returns the actual harmonic number from the array
  function getCurrentHarmonicNumber() {
    if (tubeType === 'open') {
      return openTubeHarmonics[harmonicIndex];
    } else {
      return closedTubeHarmonics[harmonicIndex];
    }
  }

  /****************************************************
   * 3. WAVE EQUATIONS
   ****************************************************/

  // Pressure, both ends open: sin(n * π * x / L)
  function waveOpenPressure(x, n) {
    return Math.sin((n * Math.PI * x) / L);
  }

  // Pressure, one end closed: sin(oddN * π * x / (2L)), oddN = 1,3,5...
  function waveClosedPressure(x, oddN) {
    return Math.sin((oddN * Math.PI * x) / (2 * L));
  }

  // Displacement, both ends open: cos(n * π * x / L)
  function waveOpenDisplacement(x, n) {
    return Math.cos((n * Math.PI * x) / L);
  }

  // Displacement, one end closed: cos(oddN * π * x / (2L))
  function waveClosedDisplacement(x, oddN) {
    return Math.cos((oddN * Math.PI * x) / (2 * L));
  }

  // Choose the correct wave function for the shape (no time factor)
  function waveShape(xPhysical) {
    const nVal = getCurrentHarmonicNumber();
    if (tubeType === 'open') {
      if (waveType === 'pressure') {
        return waveOpenPressure(xPhysical, nVal);
      } else {
        return waveOpenDisplacement(xPhysical, nVal);
      }
    } else {
      // tubeType === 'closed'
      if (waveType === 'pressure') {
        return waveClosedPressure(xPhysical, nVal);
      } else {
        return waveClosedDisplacement(xPhysical, nVal);
      }
    }
  }

  // Full wave with time factor: waveShape(x)*cos(ωt)
  function waveTime(xPhysical, t) {
    return waveShape(xPhysical) * Math.cos(omega * t);
  }

  /****************************************************
   * 4. DRAWING FUNCTIONS
   ****************************************************/

  // Master draw function
  function drawAll() {
    ctx.clearRect(0, 0, width, height);
    drawTubeWalls();
    drawEnvelope();        // black envelope for max amplitude
    drawAnimatedWave(0);   // if not animating, just show time=0 snapshot
  }

  // Draw the thick horizontal lines (top & bottom) to represent the tube.
  // If one end is closed, draw a thick vertical line at the left margin.
  function drawTubeWalls() {
    ctx.lineWidth = 8;
    ctx.strokeStyle = 'gray';

    // Horizontal top
    ctx.beginPath();
    ctx.moveTo(marginLeft, marginTop);
    ctx.lineTo(width - marginRight, marginTop);
    ctx.stroke();

    // Horizontal bottom
    ctx.beginPath();
    ctx.moveTo(marginLeft, height - marginBottom);
    ctx.lineTo(width - marginRight, height - marginBottom);
    ctx.stroke();

    // If closed, draw vertical line at left margin
    if (tubeType === 'closed') {
      ctx.beginPath();
      ctx.moveTo(marginLeft, marginTop);
      ctx.lineTo(marginLeft, height - marginBottom);
      ctx.stroke();
    }
  }

  // Draw black envelope (maximum amplitude)
  function drawEnvelope() {
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#000';

    // Top half of envelope
    ctx.beginPath();
    for (let px = 0; px <= tubeWidth; px++) {
      const xPhysical = (px / tubeWidth) * L; // map canvas px -> [0, L]
      const val = Math.abs(waveShape(xPhysical));
      const y = midY - val * (tubeHeight / 2) * 0.9;
      const cx = marginLeft + px; // shift by marginLeft
      if (px === 0) {
        ctx.moveTo(cx, y);
      } else {
        ctx.lineTo(cx, y);
      }
    }
    // Bottom half of envelope
    for (let px = tubeWidth; px >= 0; px--) {
      const xPhysical = (px / tubeWidth) * L;
      const val = Math.abs(waveShape(xPhysical));
      const y = midY + val * (tubeHeight / 2) * 0.9;
      const cx = marginLeft + px;
      ctx.lineTo(cx, y);
    }
    ctx.closePath();
    ctx.stroke();

    // Optionally, draw phase lines inside the envelope (if NUM_PHASE_LINES>0)
    if (NUM_PHASE_LINES > 0) {
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
      for (let i = 1; i < NUM_PHASE_LINES; i++) {
        const phaseFrac = i / NUM_PHASE_LINES;
        drawSnapshotInside(phaseFrac * 2 * Math.PI);
      }
    }
  }

  // Draw one “snapshot” inside the envelope, with a time phase
  function drawSnapshotInside(phase) {
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let px = 0; px <= tubeWidth; px++) {
      const xPhysical = (px / tubeWidth) * L;
      const val = waveShape(xPhysical) * Math.cos(phase);
      const y = midY - val * (tubeHeight / 2) * 0.9;
      const cx = marginLeft + px;
      if (px === 0) ctx.moveTo(cx, y);
      else ctx.lineTo(cx, y);
    }
    ctx.stroke();
  }

  // Draw the wave at a given time in BLUE
  function drawAnimatedWave(tVal) {
    ctx.lineWidth = 3;
    ctx.strokeStyle = 'blue';
    ctx.beginPath();
    for (let px = 0; px <= tubeWidth; px++) {
      const xPhysical = (px / tubeWidth) * L;
      const val = waveTime(xPhysical, tVal);
      const y = midY - val * (tubeHeight / 2) * 0.9;
      const cx = marginLeft + px;
      if (px === 0) ctx.moveTo(cx, y);
      else ctx.lineTo(cx, y);
    }
    ctx.stroke();
  }

  /****************************************************
   * 5. ANIMATION LOOP
   ****************************************************/
  function startAnimation() {
    isAnimating = true;
    toggleAnimBtn.textContent = 'Pause';
    requestAnimationFrame(animateFrame);
  }

  function stopAnimation() {
    isAnimating = false;
    toggleAnimBtn.textContent = 'Play';
  }

  function animateFrame() {
    if (!isAnimating) return;

    time += dt;
    // Redraw everything each frame
    ctx.clearRect(0, 0, width, height);
    drawTubeWalls();
    drawEnvelope();
    drawAnimatedWave(time);

    requestAnimationFrame(animateFrame);
  }

  /****************************************************
   * 6. INITIALIZATION
   ****************************************************/
  updateSliderRange();
  updateHarmonicDisplay();
  drawAll(); // initial static draw
</script>

</body>
</html>
