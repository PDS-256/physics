<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Standing Waves in a Tube</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
      background: #f9f9f9;
    }
    h1 {
      margin-bottom: 0.5em;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      align-items: center;
      margin-bottom: 1em;
    }
    .radio-group, .slider-group, .wave-type-group {
      background: #fff;
      padding: 1em;
      border: 1px solid #ccc;
      border-radius: 6px;
    }
    .radio-group label,
    .slider-group label,
    .wave-type-group label {
      margin-right: 10px;
    }
    .slider-group input[type="range"] {
      width: 200px;
      margin: 0 10px;
    }
    canvas {
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 6px;
      display: block;
      margin-top: 20px;
    }
  </style>
</head>
<body>

<h1>Standing Waves in a Tube</h1>

<div class="controls">
  <!-- Radio Buttons: Both Ends Open vs. One End Closed -->
  <div class="radio-group">
    <label>
      <input type="radio" name="tubeType" value="open" checked />
      Both Ends Open
    </label>
    <label>
      <input type="radio" name="tubeType" value="closed" />
      One End Closed
    </label>
  </div>

  <!-- Radio Buttons: Pressure vs. Displacement -->
  <div class="wave-type-group">
    <label>
      <input type="radio" name="waveType" value="pressure" checked />
      Pressure
    </label>
    <label>
      <input type="radio" name="waveType" value="displacement" />
      Displacement
    </label>
  </div>

  <!-- Slider for harmonic index -->
  <div class="slider-group">
    <label for="harmonicSlider">Harmonic (n):</label>
    <input type="range" id="harmonicSlider" min="0" max="5" step="1" value="0"/>
    <span id="harmonicValue">1</span>
  </div>
</div>

<canvas id="waveCanvas" width="800" height="250"></canvas>

<script>
  /****************************************************
   * 1. GLOBAL PARAMETERS & DOM REFERENCES
   ****************************************************/

  // Tube length in abstract units
  const L = 1.0;

  // For drawing multiple "phase" lines inside the envelope
  const NUM_PHASE_LINES = 6;

  // Canvas & Context
  const canvas = document.getElementById('waveCanvas');
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;

  // UI Elements
  const tubeTypeRadios = document.getElementsByName('tubeType');
  const waveTypeRadios = document.getElementsByName('waveType');
  const harmonicSlider = document.getElementById('harmonicSlider');
  const harmonicValue = document.getElementById('harmonicValue');

  // We'll store possible harmonic sets:
  //   Open tube: n = 1, 2, 3, 4, 5, ...
  //   Closed tube: n = 1, 3, 5, 7, 9, ...
  // For demonstration, let's keep them short.
  const openTubeHarmonics = [1, 2, 3, 4, 5, 6];
  const closedTubeHarmonics = [1, 3, 5, 7, 9, 11];

  // Track current state
  let tubeType = 'open';          // 'open' or 'closed'
  let waveType = 'pressure';      // 'pressure' or 'displacement'
  let harmonicIndex = 0;          // index in the array, not the actual "n"
                                  // (e.g., 0 -> n=1, 1 -> n=2, ...)

  /****************************************************
   * 2. EVENT LISTENERS & UI UPDATES
   ****************************************************/

  // 2a. Tube type change
  tubeTypeRadios.forEach(radio => {
    radio.addEventListener('change', (event) => {
      tubeType = event.target.value;
      // Reset to first harmonic in that tube type
      harmonicIndex = 0;
      harmonicSlider.value = 0;
      updateHarmonicDisplay();
      updateSliderRange();
      drawWave();
    });
  });

  // 2b. Wave type change
  waveTypeRadios.forEach(radio => {
    radio.addEventListener('change', (event) => {
      waveType = event.target.value;
      drawWave();
    });
  });

  // 2c. Harmonic slider change
  harmonicSlider.addEventListener('input', () => {
    harmonicIndex = parseInt(harmonicSlider.value, 10);
    updateHarmonicDisplay();
    drawWave();
  });

  // Updates the range of the slider based on tube type
  function updateSliderRange() {
    if (tubeType === 'open') {
      harmonicSlider.max = openTubeHarmonics.length - 1;
    } else {
      harmonicSlider.max = closedTubeHarmonics.length - 1;
    }
  }

  // Display the actual harmonic number (e.g., 1,3,5,...)
  function updateHarmonicDisplay() {
    const n = getCurrentHarmonicNumber();
    harmonicValue.textContent = n.toString();
  }

  // Returns the actual harmonic number from the array
  function getCurrentHarmonicNumber() {
    if (tubeType === 'open') {
      return openTubeHarmonics[harmonicIndex];
    } else {
      return closedTubeHarmonics[harmonicIndex];
    }
  }

  /****************************************************
   * 3. WAVE EQUATIONS
   ****************************************************/

  // 3a. Pressure, Both Ends Open:
  //     Node at x=0 and x=L => sin(n π x / L)
  function waveOpenPressure(x, n) {
    return Math.sin((n * Math.PI * x) / L);
  }

  // 3b. Pressure, One End Closed:
  //     Node at x=0 (open end), antinode at x=L (closed end)
  //     => sin((2m - 1) π x / (2L)) but we store n=1,3,5 => n itself is odd
  //     We'll just interpret the array as the actual factor: n π x / (2L)
  function waveClosedPressure(x, oddN) {
    // oddN is 1,3,5,... so formula is sin( oddN * π x / (2L) )
    return Math.sin((oddN * Math.PI * x) / (2 * L));
  }

  // 3c. Displacement, Both Ends Open:
  //     Antinode at x=0 and x=L => cos(n π x / L)
  //     (or equivalently sin(n π x / L + π/2), but cos is simpler)
  function waveOpenDisplacement(x, n) {
    return Math.cos((n * Math.PI * x) / L);
  }

  // 3d. Displacement, One End Closed:
  //     Open end at x=0 => displacement antinode,
  //     Closed end at x=L => displacement node
  //     => cos( oddN * π x / (2L) )
  function waveClosedDisplacement(x, oddN) {
    return Math.cos((oddN * Math.PI * x) / (2 * L));
  }

  // Chooses the correct wave function based on tubeType & waveType
  function waveFn(x) {
    const nVal = getCurrentHarmonicNumber();
    if (tubeType === 'open') {
      if (waveType === 'pressure') {
        return waveOpenPressure(x, nVal);
      } else {
        return waveOpenDisplacement(x, nVal);
      }
    } else {
      // tubeType === 'closed'
      if (waveType === 'pressure') {
        return waveClosedPressure(x, nVal);
      } else {
        return waveClosedDisplacement(x, nVal);
      }
    }
  }

  /****************************************************
   * 4. DRAWING THE WAVE + TUBE
   ****************************************************/

  function drawWave() {
    ctx.clearRect(0, 0, width, height);

    // 4a. Draw the tube "walls"
    drawTubeWalls();

    // 4b. Draw the black envelope
    drawEnvelope();

    // 4c. Draw multiple phase lines (lighter curves inside)
    drawPhaseLines();
  }

  // Draw thick horizontal lines (top and bottom).
  // If "closed," also draw a vertical line at x=0 (assuming left end is closed).
  function drawTubeWalls() {
    ctx.lineWidth = 4;
    ctx.strokeStyle = 'gray';

    // Horizontal line at top
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(width, 0);
    ctx.stroke();

    // Horizontal line at bottom
    ctx.beginPath();
    ctx.moveTo(0, height);
    ctx.lineTo(width, height);
    ctx.stroke();

    // If tube is "one end closed," draw a vertical line at x=0
    // (You could also interpret it as the right end closed, but let's do left.)
    if (tubeType === 'closed') {
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(0, height);
      ctx.stroke();
    }
  }

  // Draw envelope (maximum amplitude shape) in black
  function drawEnvelope() {
    const midY = height / 2;

    // Top half of envelope
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#000';
    ctx.beginPath();
    for (let px = 0; px <= width; px++) {
      const xPhysical = (px / width) * L;
      const val = Math.abs(waveFn(xPhysical));
      const y = midY - val * (height / 2) * 0.9; // 0.9 for margin
      if (px === 0) {
        ctx.moveTo(px, y);
      } else {
        ctx.lineTo(px, y);
      }
    }
    // Bottom half of envelope
    for (let px = width; px >= 0; px--) {
      const xPhysical = (px / width) * L;
      const val = Math.abs(waveFn(xPhysical));
      const y = midY + val * (height / 2) * 0.9;
      ctx.lineTo(px, y);
    }
    ctx.closePath();
    ctx.stroke();
  }

  // Draw multiple snapshots (phase lines) inside the envelope
  function drawPhaseLines() {
    const midY = height / 2;
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(0, 128, 255, 0.2)'; // light blue

    for (let phaseIndex = 0; phaseIndex < NUM_PHASE_LINES; phaseIndex++) {
      const timeFactor = (2 * Math.PI * phaseIndex) / NUM_PHASE_LINES;
      ctx.beginPath();
      for (let px = 0; px <= width; px++) {
        const xPhysical = (px / width) * L;
        // Standing wave ~ waveFn(x) * cos(ω t).
        // We'll approximate cos(ω t) by cos(timeFactor).
        const val = waveFn(xPhysical) * Math.cos(timeFactor);
        const y = midY - val * (height / 2) * 0.9;
        if (px === 0) {
          ctx.moveTo(px, y);
        } else {
          ctx.lineTo(px, y);
        }
      }
      ctx.stroke();
    }
  }

  /****************************************************
   * 5. INITIALIZATION
   ****************************************************/
  // Set initial slider range & label
  updateSliderRange();
  updateHarmonicDisplay();

  // Initial draw
  drawWave();
</script>

</body>
</html>
